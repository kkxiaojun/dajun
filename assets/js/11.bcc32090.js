(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{210:function(_,v,t){"use strict";t.r(v);var a=t(0),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"v8浏览器渲染引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8浏览器渲染引擎"}},[_._v("#")]),_._v(" V8浏览器渲染引擎")]),_._v(" "),t("h3",{attrs:{id:"v8-内存限制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8-内存限制"}},[_._v("#")]),_._v(" V8 内存限制")]),_._v(" "),t("p",[_._v("V8 为什么要给它设置内存上限？")]),_._v(" "),t("p",[_._v("究其根本，是由两个因素所共同决定的，一个是"),t("strong",[_._v("JS单线程的执行机制")]),_._v("，另一个是JS"),t("strong",[_._v("垃圾回收机制")]),_._v("的限制。")]),_._v(" "),t("ol",[t("li",[_._v("首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么运行逻辑将受到影响")]),_._v(" "),t("li",[_._v("V8 做了一个简单粗暴的选择，那就是限制堆内存（避免造成卡顿、相应能力下降）")])]),_._v(" "),t("h3",{attrs:{id:"v8垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8垃圾回收"}},[_._v("#")]),_._v(" V8垃圾回收")]),_._v(" "),t("p",[t("strong",[_._v("栈内存：")]),_._v(" 当ESP指针(记录当前执行状态的指针)下移，也就是上下文切换之后，栈顶的空间会自动被回收")]),_._v(" "),t("p",[t("strong",[_._v("堆内存：")]),_._v(" V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为"),t("strong",[_._v("新生代和老生代两部分")]),_._v("。")]),_._v(" "),t("img",{attrs:{src:_.$withBase("/image/browser/scavenge.png"),alt:"foo"}}),_._v(" "),t("h4",{attrs:{id:"新生代算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新生代算法"}},[_._v("#")]),_._v(" 新生代算法")]),_._v(" "),t("ol",[t("li",[_._v("新生代中的对象一般存活时间较短，内存设置的足够小（每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但"),t("font",{attrs:{color:"red"}},[_._v("复制操作需要时间成本")]),_._v("，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。）")],1),_._v(" "),t("li",[_._v("使用 Scavenge算法。")])]),_._v(" "),t("p",[t("code",[_._v("Scavenge")])]),_._v(" "),t("p",[_._v("在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。\n特点：")]),_._v(" "),t("ol",[t("li",[_._v("Scavenge 算法主要就是解决"),t("font",{attrs:{color:"green"}},[_._v("内存碎片")]),_._v("的问题")],1),_._v(" "),t("li",[_._v("劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象")]),_._v(" "),t("li",[_._v("新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了"),t("font",{attrs:{color:"green"}},[_._v("对象晋升策略")]),_._v("，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。")],1)]),_._v(" "),t("h4",{attrs:{id:"老生代算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#老生代算法"}},[_._v("#")]),_._v(" 老生代算法")]),_._v(" "),t("p",[_._v("老生代中的对象一般存活时间较长且数量也多，使用了"),t("strong",[_._v("标记 - 清除（Mark-Sweep）"),t("strong",[_._v("算法和")]),_._v("标记（Mark-Compact）-整理")]),_._v("算法。")]),_._v(" "),t("p",[_._v("在讲算法前，先来说下什么情况下对象会出现在老生代空间中：")]),_._v(" "),t("ul",[t("li",[_._v("新生代中的对象是否已经经历过一次 Scavenge 算法。")]),_._v(" "),t("li",[_._v("To 空间的对象占比大小超过 25 %。")])]),_._v(" "),t("p",[_._v("老生代中的空间很复杂，有如下几个空间")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("enum AllocationSpace {\n  // TODO(v8:7464): Actually map this space's memory as read-only.\n  RO_SPACE,    // 不变的对象空间\n  NEW_SPACE,   // 新生代用于 GC 复制算法的空间\n  OLD_SPACE,   // 老生代常驻对象空间\n  CODE_SPACE,  // 老生代代码对象空间\n  MAP_SPACE,   // 老生代 map 对象\n  LO_SPACE,    // 老生代大空间对象\n  NEW_LO_SPACE,  // 新生代大空间对象\n\n  FIRST_SPACE = RO_SPACE,\n  LAST_SPACE = NEW_LO_SPACE,\n  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,\n  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE\n};\n")])])]),t("p",[_._v("在老生代中，以下情况会先启动标记清除算法：")]),_._v(" "),t("ul",[t("li",[_._v("某一个空间没有分块的时候")]),_._v(" "),t("li",[_._v("空间中被对象超过一定限制")]),_._v(" "),t("li",[_._v("空间不能保证新生代中的对象移动到老生代中")])]),_._v(" "),t("p",[_._v("在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。")]),_._v(" "),t("p",[_._v("清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。")]),_._v(" "),t("h3",{attrs:{id:"v8-执行一段js代码的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8-执行一段js代码的过程"}},[_._v("#")]),_._v(" V8 执行一段JS代码的过程")]),_._v(" "),t("img",{attrs:{src:_.$withBase("/image/browser/v8code.png"),alt:"foo"}}),_._v(" "),t("p",[_._v("从图中你可以看出这二者的执行流程，大致可阐述为如下：")]),_._v(" "),t("ol",[t("li",[_._v("在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。")]),_._v(" "),t("li",[_._v("在解释型语言（javascript）的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。")])]),_._v(" "),t("h4",{attrs:{id:"_1-生成ast和执行上下文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-生成ast和执行上下文"}},[_._v("#")]),_._v(" 1. 生成AST和执行上下文")]),_._v(" "),t("p",[_._v("生成 AST 分为两步——词法分析和语法分析。")]),_._v(" "),t("p",[t("strong",[_._v("分词（词法分析）")]),_._v("\n其作用是将一行行的源码拆解成一个个 token。所谓token，指的是语法上不可能再分的、最小的单个字符或字符串。\n"),t("img",{attrs:{src:_.$withBase("/image/browser/v8code1.png"),alt:"foo"}})]),_._v(" "),t("p",[t("strong",[_._v("解析（语法分析）")]),_._v("\n其作用是将上一步生成的 token 数据，根据语法规则转为 AST")]),_._v(" "),t("h4",{attrs:{id:"_2-生成字节码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-生成字节码"}},[_._v("#")]),_._v(" 2. 生成字节码")]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),t("p",[_._v("字节码是介于AST 和 机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。")])]),_._v(" "),t("p",[_._v("有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition（点火器） 就登场了，它会根据 AST 生成字节码，并解释执行字节码。")]),_._v(" "),t("p",[_._v("不直接转换为机器码是因为：机器码的体积太大，移动端引发了严重的内存占用问题。")]),_._v(" "),t("h4",{attrs:{id:"_3-执行代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-执行代码"}},[_._v("#")]),_._v(" 3. 执行代码")]),_._v(" "),t("p",[_._v("通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。")]),_._v(" "),t("p",[_._v("字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为"),t("strong",[_._v("即时编译（JIT）")]),_._v("。")])])}),[],!1,null,null,null);v.default=s.exports}}]);