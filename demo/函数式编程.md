# 函数式编程
https://lucifer.ren/fe-interview/#/?id=%e7%bc%96%e7%a8%8b%e8%8c%83%e5%bc%8f
## 函数式原理

1. 什么是函数式的原理
数学公式，加法结合律｜因式分解｜完全平方公式- 原子组合的变化

2. 理论思想iu
 - 函数式一等公民
 - 

## 函数科里化（实现该函数）（加工）
柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术

这样理解柯里化 ：用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数

1. 参数复用：柯里化允许我们通过部分应用参数来创建新的函数。这样可以在不完全传递所有参数的情况下，生成一个接收剩余参数的新函数。这样可以方便地复用函数，减少重复代码。

2. 延迟执行：柯里化可以延迟函数的执行。通过将函数分解为一系列接收单个参数的函数，我们可以在需要时逐个传递参数，最终执行函数。这种延迟执行的特性可以用于创建更灵活的函数调用链。

3. 函数组合：柯里化使得函数组合更加简洁和方便。通过将函数转换为柯里化形式，我们可以更容易地将多个函数组合在一起，形成新的函数。这种函数组合的方式有助于创建更复杂的逻辑和功能。

4. 提供更高级的抽象能力：柯里化是函数式编程的重要概念之一，它使得函数的操作更加抽象和通用。通过柯里化，我们可以编写更灵活、可组合和可测试的函数，从而提高代码的可读性和可维护性。

实现：
```js
const curry = fn => {
  return (...args) => {
    if (args.length >= fn.length) {
      return fn(...args);
    } else {
      return curry(fn.bind(null, ...args));
    }
  };
};

const add = (a, b, c) => a + b + c;

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 输出 6
console.log(curriedAdd(1, 2)(3)); // 输出 6
console.log(curriedAdd(1)(2, 3)); // 输出 6
console.log(curriedAdd(1, 2, 3)); // 输出 6
```

## 函数式编程
1. 拥抱纯函数，隔离副作用
2. 函数式一等公民（可以被当做变量一样用）
3. 避免对状态的改变（不可变值）

### 纯函数与副作用
1. 纯函数，对于相同的输入，总会有相同的输出（有且仅有显式数据流）
2. 执行过程中，没有语义上副作用

副作用：除了计算外，还干其它的事情、

为什么非纯不可：副作用，隐式数据流

### 一等公民

> 头等函数的核心特征是“可以被当做变量一样用”

- 可以被当作参数传递给其他函数
- 可以作为另一个函数的返回值
- 可以被赋值给一个变量

### 不可变数据，持久化数据（非常重要, 非常重要，要懂原理分析，结合低代码项目，状态管理工具一一说明）
1. 拷贝(数据量大，冗余字段多)
2. 类似immutable.js不可变值（原理：只针对变化的字段创建新的数据，不变的保存的指向之前的对象的索引）；比如git的commit(Git 快照保存文件索引，而不会保存文件本身（只会新建变化的文件）,这是持久化数据结构的核心思想)
3. immutable.js，字典树存储数据(immutable-js 使用了另一套数据结构的 API ，与我们的常见操作有些许不同，它将所有的原生数据类型（Object， Array等）都会转化成 immutable-js 的内部对象（自己实现Map，List 等），并且任何操作最终都会返回一个新的 immutable 的值。)
4. immer.js,使用原生数据结构, API少，使用了一个 ES6 的新特性 Proxy 对象


**设计思路**：

* 对于 Immutable.js 来说，它通过构建一套原生 JS 无法支持的 Trie(字典树，只针对变化的字段创建新的数据，不变的保存的指向之前的对象的索引) 数据结构，最终实现了树节点的按需创建。
示例：
obj有a,b,c三个属性，修改b属性，只新建b属性，a,c是索引


* 对于 Immer.js 来说，它借助 Proxy 的 getter 函数实现了按需代理，借助 Proxy 的 setter 函数实现了对象属性的按需拷贝。(核心api,Produce怎么实现的（）)
无论是“精准拷贝”、“修改时拷贝”，还是“逐层拷贝”，其背后体现的都是同一个思想——“按需”。

## compose/pipe

```js
    function add4(num) {
      return num + 4
    }  

    function multiply3(num) {
      return num*3
    }  

    function divide2(num) {
      return num/2
    }
  const compose = (...funcs) => funcs.reduce((a,b) => (...args) => a(b(...args)))
  const pipe = (...funcs) => funcs.reduce((a,b) => (...args) => b(a(...args)))
```

## 函数式思想在React中的应用

**1. 数据驱动视图**
```js
	UI = render(data)
	UI = f(data)
```

**2. 组件设计：组件即函数**

**3. react hooks**
逻辑和视图耦合的问题

## 状态管理的库对比和使用（扩展到不可变数据流）
* zustand
* hox
* redux（纯函数）

## redux工作流程

单向数据流
高阶组建
订阅发布

- 纯函数 reducer
- 不可变数据原则
- 中间件，函数科里化的过程
- 函数组合，compose


## rxjs 响应式编程
RxJS 是一个在 JavaScript 中实现响应式编程的库，它利用可观察序列（Observable）来表达异步数据流，并通过一系列的操作符（Operators）来对这些数据流进行转换、筛选和组合，最终实现业务逻辑。

## 管道，流

