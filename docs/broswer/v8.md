## V8浏览器渲染引擎
### V8 内存限制
V8 为什么要给它设置内存上限？

究其根本，是由两个因素所共同决定的，一个是**JS单线程的执行机制**，另一个是JS**垃圾回收机制**的限制。

1. 首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么运行逻辑将受到影响
2. V8 做了一个简单粗暴的选择，那就是限制堆内存（避免造成卡顿、相应能力下降）

### V8垃圾回收

**栈内存：** 当ESP指针(记录当前执行状态的指针)下移，也就是上下文切换之后，栈顶的空间会自动被回收

**堆内存：** V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为**新生代和老生代两部分**。

<img :src="$withBase('/image/browser/scavenge.png')" alt="foo">

#### 新生代算法
1. 新生代中的对象一般存活时间较短，内存设置的足够小（每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但<font color=red>复制操作需要时间成本</font>，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。）
2. 使用 Scavenge算法。

`Scavenge`

在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。
特点：
1. Scavenge 算法主要就是解决<font color=green>内存碎片</font>的问题
2. 劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象
3. 新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了<font color=green>对象晋升策略</font>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。
#### 老生代算法

老生代中的对象一般存活时间较长且数量也多，使用了**标记 - 清除（Mark-Sweep）**算法和**标记（Mark-Compact）-整理**算法。

在讲算法前，先来说下什么情况下对象会出现在老生代空间中：

- 新生代中的对象是否已经经历过一次 Scavenge 算法。
- To 空间的对象占比大小超过 25 %。

老生代中的空间很复杂，有如下几个空间

```
enum AllocationSpace {
  // TODO(v8:7464): Actually map this space's memory as read-only.
  RO_SPACE,    // 不变的对象空间
  NEW_SPACE,   // 新生代用于 GC 复制算法的空间
  OLD_SPACE,   // 老生代常驻对象空间
  CODE_SPACE,  // 老生代代码对象空间
  MAP_SPACE,   // 老生代 map 对象
  LO_SPACE,    // 老生代大空间对象
  NEW_LO_SPACE,  // 新生代大空间对象

  FIRST_SPACE = RO_SPACE,
  LAST_SPACE = NEW_LO_SPACE,
  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,
  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE
};
```

在老生代中，以下情况会先启动标记清除算法：

- 某一个空间没有分块的时候
- 空间中被对象超过一定限制
- 空间不能保证新生代中的对象移动到老生代中

在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。

清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。

### V8 执行一段JS代码的过程
<img :src="$withBase('/image/browser/v8code.png')" alt="foo">

从图中你可以看出这二者的执行流程，大致可阐述为如下：

1. 在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。
2. 在解释型语言（javascript）的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。

#### 1. 生成AST和执行上下文
生成 AST 分为两步——词法分析和语法分析。

**分词（词法分析）**
其作用是将一行行的源码拆解成一个个 token。所谓token，指的是语法上不可能再分的、最小的单个字符或字符串。
<img :src="$withBase('/image/browser/v8code1.png')" alt="foo">

**解析（语法分析）**
其作用是将上一步生成的 token 数据，根据语法规则转为 AST

#### 2. 生成字节码
::: tip
字节码是介于AST 和 机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。
:::
有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition（点火器） 就登场了，它会根据 AST 生成字节码，并解释执行字节码。

不直接转换为机器码是因为：机器码的体积太大，移动端引发了严重的内存占用问题。

#### 3. 执行代码
通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。

字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为**即时编译（JIT）**。